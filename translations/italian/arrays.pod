=head1 Array

Z<arrays>
X<arrays>

Gli I<array> del Perl 5 sono una struttura dati I<first-class>--il linguaggio li supporta
come tipo di dati nativo--che memorizza zero o più scalari. Potete accedere
a singoli membri dell'array con defli indici interi, e potete aggiungere o rimuovere
elementi a piacere.

X<C<@> sigil>
X<sigils; C<@>>

Il sigillo C<@> denota un array. Per dichiarare un array, scrivete:

=begin programlisting

    my @items;

=end programlisting

=head2 Elementi di un Array

X<sigils; variant>
X<C<$>; sigil>
X<sigils; C<$>>

I<Accedere> a un singolo elemento di un array in Perl 5 richiede il sigillo
scalare. C<$cats[0]> è un uso non ambiguo dell'array C<@cats>, dato che
le parentesi quadre (C<[]>) postfisse (L<fixity>) indicano sempre un accesso indicizzato a un array.

Il primo elemento di un array ha indice zero:

=begin programlisting

    # @cats contiene una lista di oggetti Cat
    my $first_cat = $cats[0];

=end programlisting

L'ultimo indice di un array dipende dal numero di elementi nell'array. In contesto
scalare (indotto da un assegnamento scalare, una concatenzaione di stringhe,
un'addizione o un contesto booleano), un array valuta al numero di elementi nell'array:

=begin programlisting

    # assegnamento scalare
    my $num_cats = @cats;

    # concatenazione di stringhe
    say 'I have ' . @cats . ' cats!';

    # addizione
    my $num_animals = @cats + @dogs + @fish;

    # contesto booleano
    say 'Esatto, un padrone di gatti!' if @cats;

=end programlisting

Per ottenere l'I<indice> dell'ultimo elemento di un array, sottraete uno dal
numero di elementi dell'array (ricordate che gli indici dell'array iniziano da 0):

=begin programlisting

    my $first_index = 0;
    my $last_index  = @cats - 1;

    say   "Il mio primo gatto ha indice $first_index, "
        . "e il mio ultimo gatto ha indice $last_index."

=end programlisting

X<C<$#>; sigil>
X<sigils; C<$#>>

Anche la meno elegante sintassi C<$#cats> valuta all'ultimo indice dell'array:

=begin programlisting

    my $first_index = 0;
    B<my $last_index  = $#cats;>

    say   "Il mio primo gatto ha indice $first_index, "
        . "e il mio ultimo gatto ha indice $last_index."

=end programlisting

... sebbene sia spesso ancora più chiaro usare invece degli indici di array negativi. L'ultimo
elemento di un array è accessibile all'indice C<-1>. Il penultimo elemento
dell'array è accessibile all'indice C<-2>, e così via:

=begin programlisting

    my $last_cat           = $cats[-1];
    my $second_to_last_cat = $cats[-2];

=end programlisting

C<$#> ha un ulteriore uso: I<assegnandogli> un valore si può ridimensionare un array.
Ricordate che gli array in Perl 5 sono mutabili. Si espandono o contraggono secondo la necessità.
Quando restringete un array, Perl scarterà i valori per cui non c'è posto nell'array
ridimensionato. Quando espandete un array, Perl riempirà le posizioni espanse
di C<undef>.

=head2 Assegnamento ad Array

Potete fare assegnamenti a singole posizioni in un array usando gli indici:

=begin programlisting

    my @cats;
    $cats[3] = 'Jack';
    $cats[2] = 'Tuxedo';
    $cats[0] = 'Daisy';
    $cats[1] = 'Petunia';
    $cats[4] = 'Brad';
    $cats[5] = 'Choco';

=end programlisting

Se assegnate un valore a un indice oltre i limiti attuali dell'array, Perl estende
l'array alla dimensione giusta e riempie tutte le posizioni intermedie
con C<undef>. Dopo il primo assegnamento nell'esempio qui sopra, l'array conterrà
C<undef> nelle posizioni 0, 1 e 2 e C<Jack> nella posizione 3.

Come abbreviazione, potete inizializzare un arrey con una lista:

=begin programlisting

    my @cats = ( 'Daisy', 'Petunia', 'Tuxedo', ... );

=end programlisting

... ma ricordate che I<non sono> le parentesi a creare una lista. Senza
parentesi, questa istruzione assegnerebbe C<Daisy> al primo e unico elemento
dell'array, a causa delle precedenze tra operatori (L<precedence>).

Un'espressione qualunque che produce una lista in contesto lista può essere assegnata ad un array:

=begin programlisting

    my @cats     = get_cat_list();
    my @timeinfo = localtime();
    my @nums     = 1 .. 10;

=end programlisting

Assegnare a un elemento scalare di un array impone il contesto scalare, mentre
assegnare all'intero array impone il contesto lista.

Per svuotare un array, assegnategli la lista vuota:

=begin programlisting

    my @dates = ( 1969, 2001, 2010, 2051, 1787 );
    ...
    @dates    = ();

=end programlisting

=begin tip Arrays Start Empty

C<my @items = ();> è una versione più lunga e verbosa di C<my @items>, dato che
gli array appena dichiarati sono vuoti.

=end tip

=head2 Slice di Array

Z<array_slices>

X<arrays; slices>
X<slices; array>
X<C<@>; sigil>
X<sigils; C<@>>

Il costrutto di I<array slice> vi permette di accedere agli elementi di un array in contesto
lista. A differenza dell'accesso scalare a un elemento dell'array, questa operazione di indicizzazione
riceve una lista di zero o più indici e usa il sigillo array (C<@>):

=begin programlisting

    my @youngest_cats = @cats[-1, -2];
    my @oldest_cats   = @cats[0 .. 2];
    my @selected_cats = @cats[ @indexes ];

=end programlisting

Le slice di array possono essere utili negli assegnamenti:

=begin programlisting

    @users[ @replace_indices ] = @replace_users;

=end programlisting

Una slice può contenere zero o più elementi--o anche uno solo:

=begin programlisting

    # array con un singolo elemento; la chiamata di funzione è in contesto I<lista>
    @cats[-1] = get_more_cats();

    # array con un singolo elemento; la chiamata di funzione è in contesto I<scalare>
    $cats[-1] = get_more_cats();

=end programlisting

L'unica differenza sintattica tra una slice di array con un solo elemento e
l'accesso scalare a un elemento dell'array è il sigillo usato. La differenza I<semantica>
è maggiore: una slice di array impone sempre il contesto lista. Una slice di array
valutata in contesto scalare produce un warning:

=begin screen

    È meglio scrivere il valore scalare @cats[1] come $cats[1]...

=end screen

Una slice di array impone il contesto lista (L<context_philosophy>) anche all'espressione
che usa come indice:

=begin programlisting

    # la chiamata di funzione è in contesto lista
    my @hungry_cats = @cats[ get_cat_indices() ];

=end programlisting

=head2 Operazioni sugli Array

Qualche volta è più conveniente vedere un array come una collezione ordinata e mutabile di
elementi piuttosto che come una mappatura tra indici e valori. Perl 5 fornisce diverse
operazioni per manipolare gli elementi di un array senza usare gli indici.

X<arrays; C<push>>
X<arrays; C<pop>>
X<builtins; C<push>>
X<builtins; C<pop>>

Gli operatori C<push> e C<pop> aggiungono e rimuovono, rispettivamente, degli elementi dalla coda di un
array:

=begin programlisting

    my @meals;

    # cosa c'è da mangiare?
    push @meals, qw( hamburger pizza lasagne rape );

    # ... ma vostro nipote odia la verdura
    pop @meals;

=end programlisting

Potete fare il C<push> di una lista di valori in un array, ma potete solo fare il C<pop> di un elemento
per volta. C<push> restituisce il nuovo numero di elementi dell'array. C<pop> restituisce
l'elemento rimosso.

Dato che C<push> opera su una lista, potete facilmente appendere gli elementi di uno o più
 arrays tra di loro:

=begin programlisting

    push @meals, @breakfast, @lunch, @dinner;

=end programlisting

X<arrays; C<shift>>
X<arrays; C<unshift>>
X<builtins; C<shift>>
X<builtins; C<unshift>>

Analogamente, C<unshift> e C<shift> aggiungono e rimuovono, rispettivamente, degli elementi dalla testa
di un array:

=begin programlisting

    # espandiamo i nostri orizzonti culinari
    unshift @meals, qw( tofu spanakopita taquitos );

    # ripensamento su quell'idea della soia
    shift @meals;

=end programlisting

C<unshift> antepone una lista di elementi alla testa di un array e restituisce
il nuovo numero di elementi dell'array. C<shift> rimuove e restituisce il primo
elemento dell'array.

Pochi programmi usano i valori di ritorno di C<push> e C<unshift>.

X<arrays; C<splice>>
X<builtins; C<splice>>

L'operatore C<splice> rimuove e sostituisce elementi di un array dato un
offset, la lunghezza di una slice di lista e i sostituti. Sia la sostituzione che la rimozione
sono opzionali; potete omettere sia l'uno che l'altro. La descrizione di C<splice> in
C<perlfunc> dimostra la sua equivalenza con C<push>, C<pop>, C<shift> e
C<unshift>. Un uso particolarmente efficace è la rimozione di due elementi da un array:

=begin programlisting

    my ($winner, $runnerup) = splice @finalists, 0, 2;

    # oppure
    my $winner              = shift @finalists;
    my $runnerup            = shift @finalists;

=end programlisting

X<arrays; C<each>>
X<builtins; C<each>>

Prima del Perl 5.12, iterare su un array per indice richiedeva un ciclo in stile C.
A partire da Perl 5.12, C<each> può iterare su un array per indice e valore:

=begin programlisting

    while (my ($index, $value) = each @bookshelf)
    {
        say "#$index: $value";
        ...
    }

=end programlisting

=head2 Array e Contesto

X<list context; arrays>

In contesto lista, gli array diventano liste.  Se passate diversi array a una
normale funzione Perl 5, essi si appiattiscono in un'unica lista:

=begin programlisting

    my @cats = qw( Daisy Petunia Tuxedo Brad Jack );
    my @dogs = qw( Rodney Lucky );

    take_pets_to_vet( @cats, @dogs );

    sub take_pets_to_vet
    {
        # BACATO: non usatelo!
        my (@cats, @dogs) = @_;
        ...
    }

=end programlisting

Nella funzione, C<@_> conterrà sette elementi, not due, poichè l'assegnamento
di una lista ad un array è I<greedy>. Un array consuma più elementi possibile
dalla lista. Dopo l'assegnamento, C<@cats> conterrà I<tutti>
gli argomenti passati alla funzione. C<@dogs> invece sarà vuoto.

Questo appiattimento può confondere i principianti che tentano di creare
array nidificati in Perl 5:

=begin programlisting

    # crea un singolo array, non un array di array
    my @numbers = (  1 .. 10,
                  ( 11 .. 20,
                  ( 21 .. 30 ) ) );

=end programlisting

... ma questo codice è a tutti gli effetti equivalente a questo:

=begin programlisting

    # crea un singolo array, non un array di array
    my @numbers = 1 .. 30;

=end programlisting

... perchè le parentesi raggruppano semplicemente le espressioni. Non I<creano>
liste, in questo caso. Per ovviare a questo appiattimento, usate i riferimenti
ad array (L<array_references>).

=head2 Interpolazione di Array

X<arrays; interpolation>
X<interpolation; arrays>
X<C<$">>
X<C<$LIST_SEPARATOR>>

Gli array vengono interpolati in stringhe come liste della conversione in stringa di ciascun elemento
separate dal valore corrente della magica variabile globale C<$">. Il valore di default di tale
variabile è lo spazio singolo. Il suo mnemonico in F<English.pm> è
C<$LIST_SEPARATOR>. Quindi:

=begin programlisting

    my @alphabet = 'a' .. 'z';
    say "[@alphabet]";
    B<[a b c d e f g h i j k l m>
     B<n o p q r s t u v w x y z]>

=end programlisting

Localizzare temporaneamente C<$"> e assegnarle un altro valore a scopo di debugging
può essere molto comodoN<Il credito per averne dimostrato l'efficacia va a Mark Jason Dominus.>:

=begin programlisting

    # cos'è già che c'è in questo array?
    {
        local $" = ')(';
        say "(@sweet_treats)";
    }

=end programlisting

... che produce il risultato:

=begin screen

    (crostata)(torta)(ciambelle)(biscotti)(pane dolce)

=end screen
