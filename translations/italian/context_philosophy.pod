=head1 Contesto

Z<context_philosophy>

X<context>

In un linguaggio parlato, il significato di una parola o frase può dipendere dal modo in cui viene usata; il I<contesto> aiuta a chiarirne il senso.
Per esempio, l'errato uso del plurale in "Vorrei un panini, per favore!"N<Il plurale
del nome è in disaccordo con la quantità.> suona subito sbagliato, proprio come
l'errore di genere in "la gatto"N<L'articolo è femminile, mentre il nome è maschile.>. 
Considerate anche il pronome "che" o il nome "città" che possono essere singolari o plurali a seconda del contesto.

Il contesto in Perl è qualcosa di simile. Esso determina quanti e quali dati possono essere usati. 
Perl fa del suo meglio per darvi esattamente quello che chiedete--a patto che
lo chiediate utilizzando il contesto appropriato.

Alcune operazioni del Perl hanno un diverso comportamento a seconda che vogliate ottenere da loro zero, uno o
più di un risultato. Un costrutto Perl può fare due cose diverse se scrivete "Fai questo, ma non mi importa del risultato" 
piuttosto che "Fai questo, e mi aspetto più di un risultato." Altre operazioni vi permettono di specificare se
intendete lavorare con dati numerici, testuali, oppure valori logici vero e falso.

Il contesto può causare confusione se tentate di scrivere o leggere del codice Perl come una sequenza
di singole espressioni avulse da ciò che le circonda. Potrà succedervi di 
velervi dare una botta in testa dopo una lunga sessione di debugging quando finalmente scoprite che l'errore era nelle vostre assunzioni
sul contesto. Se invece tenete sempre a mente il contesto, il vostro codice sarà più corretto--oltre che pulito, flessibile e conciso.

=head2 Contesti Void, Scalare e Lista

Z<amount_context>

X<context; amount>
X<amount context>

Il I<contesto di numero> determina I<quanti> elementi vi aspettate da un'operazione.
E<Egrave> qualcosa di simile alla consonanza di numero tra soggetto e verbo in Italiano.
Anche senza conoscere formalmente questo principio, non avete probabilmente problemi a trovare l'errore nella frase "Il Perl sono un linguaggio divertente".
In Perl, il numero di elementi che vi aspettate determina quanti ne otterrete.

X<void context>
X<contxt; void>

Supponete di avere una funzione (L<functions>) con nome C<find_chores()> che ordina
la vostra lista di faccende di casa da sbrigare in base alla loro priorità. Il modo in cui chiamate
questa funzione determina cosa essa produrrà. Potreste non avere tempo di occuparvi di nulla, e in questo caso
chiamare la funzione è solo un tentativo di mostrarvi occupati.
Potreste avere abbastanza tempo per fare un lavoro, oppure avere molte energie in
un weekend libero e desiderare di sbrigare più faccende possibile.

Se chiamate la funzione senza attenderne un valore di ritorno, la chiamata
viene fatta nel I<contesto void>:

=begin programlisting

    find_chores();

=end programlisting

X<context; scalare>
X<scalar context>

Se assegnate il valore di ritorno della funzione a un singolo elemento (L<scalars>), la funzione viene valuta
in I<contesto scalare>:

=begin programlisting

    my $single_result = find_chores();

=end programlisting

X<list context>
X<context; list>

Se assegnate il risultato della chiamata alla funzione ad un array (L<arrays>) o a una
lista, o lo utilizzate in una lista, la funzione viene valutata in I<contesto lista>:

=begin programlisting

    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();
    process_list_of_results( find_chores() );

=end programlisting

Le parentesi nella seconda linea dell'esempio precedente raggruppano le due
dichiarazioni di variabli (L<lexical_scope>), e l'assegnamento si comporta come vi aspettate.
Se si volesse ignorare C<@rest>, potreste scrivere:

=begin programlisting

    my B<(>$single_elementB<)>   = find_chores();

=end programlisting

.... nel qual caso le parentesi suggeriscono al parser di Perl 5 che intendete
fare l'assegnamento in contesto lista anche se vi interessa assegnare solo un elemento della lista.
Tutto questo non è forse così ovvio, ma ora che lo sapete, la differenza di contesto di numero tra queste due istruzioni dovrebbe esservi evidente:

=begin programlisting

    my $scalar_context = find_chores();
    my B<(>$list_contextB<)> = find_chores();

=end programlisting

Valutare una funzione o una espressionein contesto lista--eccetto che negli assegnamenti--può
creare qualche confusione. Le liste propagano il contesto lista alle espressioni che
contengono, quindi entrambe queste chiamate a C<find_chores()> sono valutate in contesto lista:

=begin programlisting

    process_list_of_results( find_chores() );

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => find_chores(), # OOPS!
    );

=end programlisting

Quest'ultimo esempio sorprende spesso i programmatori principianti che si aspettano un contesto scalare
per la chiamata di funzione. Invece, inizializzare un hash (L<hashes>) con una lista di valori
impone un contesto lista alla chiamata a C<find_chores>.

X<builtins; C<scalar>>

Per imporre esplicitamente un contesto scalare, usate l'operatore C<scalar>:

=begin programlisting

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => B<scalar> find_chores(),
    );

=end programlisting

Che effetto ha il contesto di chiamata di una funzione? Una funzione context-aware può esaminare il contesto in cui è stata chiamata
e decidere di conseguenza quanto lavoro deve fare per restituire il risultato.
In contesto void, C<find_chores()> potrebbe non fare assolutamente nulla. In contesto scalare, deve trovare soltanto il compito più importante. 
In contesto lista, deve ordinare e restituire l'intera lista di faccende da sbrigare.

=head2 Contesti Numerico, Stringa e Booleano

Z<value_contexts>

X<value context>
X<context; value>

L'altro contesto del Perl--il I<contesto di valore>--determina come Perl interpreta un dato.
Probabilmente avrete già notato la flessibilità del Perl nell'indovinare se un dato è un numero o una stringa,
e nel convertire tra i due a seconda delle vostre intenzioni.
In mancanza della dichiarazione (o del tracciamento) esplicito del I<tipo> di un dato contenuto in una
variable o restituito da una funzione, i contesti di valore del Perl costituiscono importanti suggerimenti al compilatore su come gestire tali dati.

X<builtins; C<eq>>

Perl farà del suo meglio per convertire i valori al tipo appropriato (L<coercion>),
in base agli operatori che usate. Prestate attenzione ad usare il giusto operatore per il
tipo di contesto che desiderate. Supponiamo che vogliate confrontare il contenuto di due stringhe.
L'operatore C<eq> determina se le due stringhe contengono la stessa informazione I<come stringhe>:

=begin programlisting

    say "Errore catastrofico di crittografia!" if $alice eq $bob;

=end programlisting

Forse vi è capitato di essere spiacevolmente sorpresi in casi in cui I<sapevate> che le stringhe erano diverse,
ma confrontandole sono risultate uguali:

=begin programlisting

    my $alice = 'alice';
    say "Errore catastrofico di crittografia!" if $alice == 'Bob';

=end programlisting

X<string context>
X<numeric context>
X<context; string>
X<context; numeric>

X<builtins; C<==>>

L'operatore C<eq> tratta i suoi operandi come stringhe forzando il I<contesto stringa> su di essi.
Invece, l'operatore C<==> impone il I<contesto numerico>. In contesto numerico, entrambe le stringhe vengono valutate come C<0> (L<numeric_coercion>).

X<boolean context>
X<context; boolean>

Il I<contesto Booleano> occorre quando usate un valore in una istruzione condizionale. Negli esempi precedenti,
C<if> valutava il risultato degli operatori C<eq> e C<==> in contesto booleano.

X<context; explicit>

In rare occasioni, potrebbe essere necessario forzare esplicitamente un contesto se
non è possibile trovare un operatore tipato appropriato. Per forzare un contesto numerico, aggiungete zero ad una
variabile. Per forzare un contesto stringa, concatenate la variable con la stringa vuota. 
Per forzare un contesto boolean, usate due volte l'operatore di negazione:

=begin programlisting

    my $numeric_x =  0 + $x;  # forza il contesto numerico
    my $stringy_x = '' . $x;  # forza il contesto stringa
    my $boolean_x =    !!$x;  # forza il contesto booleano

=end programlisting

I contesti di tipo sono meno difficili da identificare rispetto ai contesti di numero. Una volta che
sapete della loro esistenza e conoscete i contesti dei vari operatori (L<operator_types>), è raro che possiate sbagliarvi.
