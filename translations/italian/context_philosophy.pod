=head1 Contesto

Z<context_philosophy>

X<context>

In un linguaggio parlato, il significato di una parola o frase può dipendere dal modo in cui viene usata; il I<contesto> aiuta a chiarirne il senso.
Per esempio, l'errato uso del plurale in "Vorrei un panini, per favore!"N<Il plurale
del nome è in disaccordo con la quantità.> suona subito sbagliato, proprio come
l'errore di genere in "la gatto"N<L'articolo è femminile, mentre il nome è maschile.>. 
Considerate anche il pronome "che" o il nome "città" che possono essere singolari o plurali a seconda del contesto.

Il contesto in Perl è qualcosa di simile. Esso determina quanti e quali dati possono essere usati. 
Perl fa del suo meglio per darvi esattamente quello che chiedete--a patto che
lo chiediate utilizzando il contesto appropriato.

Alcune operazioni del Perl hanno un diverso comportamento a seconda che vogliate ottenere da loro zero, uno o
più di un risultato. Un costrutto Perl può fare due cose diverse se scrivete "Fai questo, ma non mi importa del risultato" 
piuttosto che "Fai questo, e mi aspetto più di un risultato." Altre operazioni vi permettono di specificare se
intendete lavorare con dati numerici, testuali, oppure valori logici vero e falso.

Il contesto può causare confusione se tentate di scrivere o leggere del codice Perl come una sequenza
di singole espressioni avulse da ciò che le circonda. Potrà succedervi di 
darvi una botta in testa dopo una lunga sessione di debugging quando finalmente scoprite che l'errore era nelle vostre assunzioni
sul contesto. Se invece tenete sempre a mente il contesto, il vostro codice sarà più corretto--oltre che pulito, flessibile e conciso.

=head2 Contesti Void, Scalare e Lista

Z<amount_context>

X<context; amount>
X<amount context>

Il I<Contesto di numero> determina I<quanti> elementi vi aspettate da un'operazione.
E<Egrave> qualcosa di simile alla consonanza di numero tra soggetto e verbo in Italiano.
Anche senza conoscere formalmente questo principio, non avete probabilmente problemi a trovare l'errore nella frase "Il Perl sono un linguaggio divertente".
In Perl, il numero di elementi che vi aspettate determina quanti ne otterrete.

X<contesto void>
X<contesto; void>

Supponete di avere una funzione (L<functions>) con nome C<find_chores()> che ordina
la vostra lista di faccende di casa da sbrigare in base alla loro priorità. Il modo in cui chiamate
questa funzione detarmina cosa essa produrrà. Potreste non avere tempo di occuparvi di nulla, e in questo caso
chiamare la funzione è solo un tentativo di mostrarvi occupati.
Potreste avere abbastanza tempo per fare un lavoro, oppure avere molte energie in
un weekend libero e desiderare di sbrigare più faccende possibile.

Se chiamate la funzione senza attenderne un valore di ritorno, la chiamata
viene fatta nel I<contesto void>:

=begin programlisting

    find_chores();

=end programlisting

X<contesto; scalare>
X<contesto scalare>

Assigning the function's return value to a single item (L<scalars>) evaluates
the function in I<scalar context>:

=begin programlisting

    my $single_result = find_chores();

=end programlisting

X<list context>
X<context; list>

Assigning the results of calling the function to an array (L<arrays>) or a
list, or using it in a list, evaluates the function in I<list context>:

=begin programlisting

    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();
    process_list_of_results( find_chores() );

=end programlisting

The parentheses in the second line of the previous example group the two
variable declarations (L<lexical_scope>) so that assignment will behave as you
expect. If C<@rest> were to go unused, you could also correctly write:

=begin programlisting

    my B<(>$single_elementB<)>   = find_chores();

=end programlisting

.... in which case the parentheses give a hint to the Perl 5 parser that you
intend list context for the assignment even though you assign only one element
of a list. This is subtle, but now that you know about it, the difference of
amount context between these two statements should be obvious:

=begin programlisting

    my $scalar_context = find_chores();
    my B<(>$list_contextB<)> = find_chores();

=end programlisting

Evaluating a function or expression--except for assignment--in list context can
produce confusion. Lists propagate list context to the expressions they
contain. Both of these calls to C<find_chores()> occur in list context:

=begin programlisting

    process_list_of_results( find_chores() );

    my %results =
    (
        cheap_operation     => $cheap_operation_results,
        expensive_operation => find_chores(), # OOPS!
    );

=end programlisting

The latter example often surprises novice programmers who expect scalar context
for the function call. Initializing a hash (L<hashes>) with a list of values
imposes list context on C<find_chores>.

X<builtins; C<scalar>>

Use the C<scalar> operator to impose scalar context:

=begin programlisting

    my %results =
    (
        cheap_operation     => $cheap_operation_results,
        expensive_operation => B<scalar> find_chores(),
    );

=end programlisting

Why does context matter? A context-aware function can examine its calling
context and decide how much work it needs to do before returning its results.
In void context, C<find_chores()> may legitimately do nothing. In scalar
context, it can find only the most important task. In list context, it must
sort and return the entire list.

=head2 Numeric, String, and Boolean Context

Z<value_contexts>

X<value context>
X<context; value>

Another type of context determines how Perl understands a piece of data--not
I<how many> pieces of data you want, but what the data means.  You've probably
already noticed that Perl's flexible about figuring out if you have a number or
a string and converting between the two as you want them.  This I<value
context> helps to explain how it does so.  In exchange for not having to
declare (or at least track) explicitly what I<type> of data a variable contains
or a function produces, Perl offers specific type contexts that tell the
compiler how to treat a given value during an operation.

Suppose you want to compare the contents of two strings.  The C<eq> operator
tells you if the strings contain the same information:

=begin programlisting

    say "Catastrophic crypto fail!" if $alice eq $bob;

=end programlisting

You may have had a baffling experience where you I<know> that the strings are
different, but they still compare the same:

=begin programlisting

    my $alice = 'alice';
    say "Catastrophic crypto fail!" if $alice == 'Bob';  # OOPS

=end programlisting

X<string context>
X<numeric context>
X<context; string>
X<context; numeric>

The C<eq> operator treats its operands as strings by enforcing I<string
context> on them.  The C<==> operator imposes I<numeric context>.  The example
code fails because the value of both strings when treated as numbers is C<0>
(L<numeric_coercion>).

X<boolean context>
X<context; boolean>

I<Boolean context> occurs when you use a value in a conditional statement.  In
the previous examples, the C<if> statement evaluated the results of the C<eq>
and C<==> operators in boolean context.

Perl will do its best to coerce values to the proper type (L<coercion>),
depending on the operators you use.  Be sure to use the proper operator for the
type of context you want.

In rare circumstances, you may need to force an explicit context where no
appropriately typed operator exists.  To force a numeric context, add zero to a
variable.  To force a string context, concatenate a variable with the empty
string.  To force a boolean context, double the negation operator:

=begin programlisting

    my $numeric_x =  0 + $x;  # forces numeric context
    my $stringy_x = '' . $x;  # forces string  context
    my $boolean_x =    !!$x;  # forces boolean context

=end programlisting

In general, type contexts are less difficult to understand and see than the
amount contexts.  Once you understand that they exist and know which operators
provide which contexts (L<operator_types>), you'll rarely make mistakes with
them.
