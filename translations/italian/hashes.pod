=head1 Hash

Z<hashes>

X<hashes>

Un I<hash> è una struttura dati nativa del Perl che associa delle chiavi stringa a
dei valori scalari. Allo stesso modo in cui una variabile corrisponde a un'area
di memoria, una chiave di un hash si riferisce a un valore. Pensate a un hash come se
fosse una guida telefonica, con cui potete usare i nomi dei vostri amici per trovare i loro numeri di telefono.
In altri linguaggi gli hash sono detti I<tablelle>, I<array associativi>, I<dizionari>
o I<mappe>.

Gli hash hanno due proprietà importanti: memorizzano uno scalare per ogni chiave univoca e
non impongono alcun ordine specifico sulle chiavi.

=head2 Dichiarazione di Hash

Z<declaring_hashes>

X<hashes; declaring>
X<C<%>; sigil>
X<sigils; C<%>>

Gli hash usano il sigillo C<%>. Dichiarate un hash lessicale con:

=begin programlisting

    my %favorite_flavors;

=end programlisting

Un hash appena dichiarato è vuoto. Potreste anche scrivere C<my %favorite_flavors = ();>, ma
sarebbe superfluo.

X<C<$>; sigil>
X<sigils; C<$>>

Gli hash usano il sigillo C<$> quando accedete a singoli elementi e le parentesi graffe
C<{ }> per specificare la chiave:

=begin programlisting

    my %favorite_flavors;
    $favorite_flavors{Gabi}    = 'Cioccolato';
    $favorite_flavors{Annette} = 'Vaniglia';

=end programlisting

È possibile assegnare una lista di chiavi e valori ad un hash in un'unica espressione:

=begin programlisting

    my %favorite_flavors = (
        'Gabi',    'Cioccolato',
        'Annette', 'Vaniglia',
    );

=end programlisting

X<<< C<< => >>; fat comma operator >>>
X<<< operators; C<< => >> >>>

Se assegnate un numero dispari di elementi ad un hash, riceverete un warning.
Un idioma del Perl suggerisce di usare l'operatore I<fat comma> (C<< => >>)
per associare chiavi e valori, poichè rende più esplicite tali associazioni:

=begin programlisting

    my %favorite_flavors = (
        Gabi    B<< => >> 'Menta e cioccolato',
        Annette B<< => >> 'Vaniglia',
    );

=end programlisting

L'operatore fat comma funziona come la virgola, ma quota anche
la bareword (L<barewords>) che lo precede. La pragma C<strict> non genererà un warning
per la presenza di tale bareword--e se avete una funzione con lo stesso nome di una chiave
dell'hash, l'operatore fat comma I<non> chiamerà la funzione:

=begin programlisting

    sub nome { 'Leonardo' }

    my %address =
    (
        nome => 'Via Fibonacci 1123',
    );

=end programlisting

La chiave in questo hash sarà C<nome> e non C<Leonardo>. Se volete chiamare la funzione,
dovete farlo esplicitamente:

=begin programlisting

    my %address =
    (
        B<nome()> => 'Via Fibonacci 1123',
    );

=end programlisting

=begin notetip

L'assegnamento ad un hash avviene in contesto lista. Qualunque funzione chiamata durante l'assegnamento ad un
hash userà per default il contesto lista a meno che usiate esplicitamente C<scalar()>.

=end notetip

Per svuotare un hash, assegnategli la lista vuotaN<Potreste vedere occasionalmente anche C<undef
%hash>.>:

=begin programlisting

    %favorite_flavors = ();

=end programlisting

=head2 Indicizzazione di Hash

X<hashes; values>

Per accedere ai singoli valori di un hash dovete eseguire un'operazione di indicizzazione. Usate una chiave (operazione di
accesso I<per chiave>) per estrarre un valore da un hash:

=begin programlisting

    my $address = $addresses{$name};

=end programlisting

In questo esempio, C<$name> contiene una stringa che è anche una chiave dell'hash.
Come per l'accesso a un singolo elemento di un array, il sigillo dell'hash
è cambiato da C<%> a C<$> per indicare l'accesso per chiave a un valore scalare.

Potete anche usare letterali stringa come chiavi di hash. Perl quoterà le bareword
automaticamente seguendo le stesse regole del fat comma:

=begin programlisting

    # quotato automaticamente
    my $address = $addresses{Victor};

    # quotatura necessaria; non è una bareword valida
    my $address = $addresses{B<'>Sue-LinnB<'>};

    # una chiamata di funzione deve essere disambiguata
    my $address = $addresses{get_nameB<()>};

=end programlisting

=begin tip Don't Quote Me

I principianti tendono a quotare i letterali stringa che usano come chiavi di hash, mentre i programmatori esperti
evitano la quotatura quando è possibile. La quotatura delle chiavi di hash viene usata
per segnalare l'intenzione di fare qualcos'altro.

=end tip

Anche le funzioni native del Perl 5 sono soggette alla quotatura automatica:

=begin programlisting

    my %addresses =
    (
        Leonardo => 'Via Fibonacci 1123',
        Utako    => 'Hotel Cantor, Stanza 1',
    );

    sub get_address_from_name
    {
        return $addresses{B<+>shift};
    }

=end programlisting

L'operatore I<più> unario (L<unary_coercions>) converte quella che sarebbe una bareword (C<shift>)
soggetta alla quotatura automatica in un'espressione. Da questo esempio si vede che potete usare una
espressione arbitraria--non solo una chiamata di funzione--come chiave di un hash:

=begin programlisting

    # non I<fatelo> davvero, per favore
    my $address = $addresses{reverse 'odranoeL'};

    # l'interpolazione funziona
    my $address = $addresses{"$first_name $last_name"};

    # e anche le chiamate di metodi
    my $address = $addresses{ $user->name() };

=end programlisting

Le chiavi di un hash possono solo essere stringhe. Qualunque cosa valuti ad una stringa è
una chiave di hash ammissibile. Perl si spinge fino a fare la coercizione (L<coercion>) di
altri tipi nel tipo stringa, in modo che se usate un oggetto come chiave di hash, ottenete
la versione stringa dell'oggetto anzichè l'oggetto stesso:

=begin programlisting

    for my $isbn (@isbns)
    {
        my $book = Book->fetch_by_isbn( $isbn );

        # difficile che sia quello che volevate fare
        $books{$book} = $book->price;
    }

=end programlisting

=head2 Esistenza di Chiavi di Hash

X<builtins; C<exists>>
X<hashes; C<exists>>

L'operatore C<exists> restituisce un valore booleano che indica se un hash
contiene una data chiave:

=begin programlisting

    my %addresses =
    (
        Leonardo => 'Via Fibonacci 1123',
        Utako    => 'Hotel Cantor, Stanza 1',
    );

    say "Ho l'indirizzo di Leonardo"
        if exists $addresses{Leonardo};
    say "Ho l'indirizzo di Warnie"
        if exists $addresses{Warnie};

=end programlisting

Usare C<exists> anzichè tentare di accedere direttamente a una chiave di hash evita due problemi.
Prima di tutto, il controllo non viene effettuato sul I<valore> associato alla chiave; infatti una chiave di hash
potrebbe esistere e avere un valore anche se tale valore corrisponde a falso in contesto booleano (per esempio C<undef>):

=begin programlisting

    my  %false_key_value = ( 0 => '' );
    ok( %false_key_value,
         'un hash che contiene falso sia come chiave che come valore
          dovrebbe valutare a vero' );

=end programlisting

Inoltre, C<exists> evita l'autovivicazione (L<autovivification>) nelle strutture dati
nidificate (L<nested_data_structures>).

X<builtins; C<defined>>

Se una chiave di hash esiste, il suo valore potrebbe essere C<undef>. Potete controllarlo con C<defined>:

=begin programlisting

    $addresses{Leibniz} = undef;

    say "Gottfried vive a $addresses{Leibniz}"
        if exists  $addresses{Leibniz}
        && defined $addresses{Leibniz};

=end programlisting

=head2 Accedere a Chiavi e Valori degli Hash

X<hashes; C<keys>>
X<builtins; C<keys>>

Gli hash sono variabili aggregate, ma la loro struttura a coppie offre diverse
possibilità di iterazione: sulle chiavi dell'hash, sui valori dell'hash o
sulle coppie chiave/valore. L'operatore C<keys> produce una lista di chiavi di un hash:

=begin programlisting

    for my $addressee (keys %addresses)
    {
        say "Trovato l'indirizzo di $addressee!";
    }

=end programlisting

X<hashes; C<values>>
X<builtins; C<values>>

L'operatore C<values> produce una lista di valori di un hash:

=begin programlisting

    for my $address (values %addresses)
    {
        say "Qualcuno vive in $address";
    }

=end programlisting

X<hashes; C<each>>
X<builtins; C<each>>

L'operatore C<each> produce una lista di liste di due elementi contenenti una chiave e il suo valore:

=begin programlisting

    while (my ($addressee, $address) = each %addresses)
    {
        say "$addressee vive in $address";
    }

=end programlisting

Al contrario degli array, non c'è un ordinamento ovvio per queste liste. L'ordinamento
dipende dall'implementazione interna dell'hash, la versione di
Perl che state usando, la dimensione dell'hash e un ulteriore fattore random. Ciò nonostante,
l'ordine degli elementi imposto da C<keys>, C<values> e C<each> è consistente.
Modificando l'hash l'ordine potrebbe cambiare, ma se l'hash rimane immutato potete
fare affidamento su tale ordine.

Ogni hash ha un I<unico> iteratore per l'operatore C<each>. Non potete
iterare su un hash con più di un C<each> senza incorrere in problemi; se iniziate una nuova
iterazione mentre un'altra è in corso, la prima terminerà prematuramente e la seconda
inizierà da qualche parte in mezzo all'hash. Durante una iterazione C<each>, fate attenzione
a non chiamare funzioni che possano a loro volta tentare di iterare sull'hash con
C<each>.

In pratica questo succede raramente, ma quando vi dovesse servire resettate l'iteratore di un hash con C<keys> o
C<values> in contesto void:

=begin programlisting

    # resetta l'iteratore dell'hash
    keys %addresses;

    while (my ($addressee, $address) = each %addresses)
    {
        ...
    }

=end programlisting

=head2 Slice di Hash

X<hashes; slicing>
X<slices; hash>

Una I<slice di hash> è una lista di chiavi o valori di un hash indicizzata in una singola
operazione. Per inizializzare diversi elementi di un hash in una sola istruzione:

=begin programlisting

    # %cats contiene già altri elementi
    @cats{qw( Jack Brad Mars Grumpy )} = (1) x 4;

=end programlisting

Questo codice è equivalente all'inizializzazione:

=begin programlisting

    my %cats = map { $_ => 1 }
               qw( Jack Brad Mars Grumpy );

=end programlisting

...eccetto che l'inizializzazione di uno slice di hash non I<sostituisce> i contenuti di un hash
che esistono già.

X<C<@>; sigil>
X<sigils; C<@>>

Le slice di hash vi permettono anche di estrarre diversi valori da un hash in un'unica
operazione. Come per le slice di array, il sigillo dell'hash cambia per indicare il contesto
lista. L'uso delle parentesi graffe indica accesso per chiave rendendo non ambigua la 
presenza di un hash:

=begin programlisting

    my @buyer_addresses = @addresses{ @buyers };

=end programlisting

Le slice di hash rendono facile anche fondere due hash insieme:

=begin programlisting

    my %addresses        = ( ... );
    my %canada_addresses = ( ... );

    @addresses{ keys   %canada_addresses }
              = values %canada_addresses;

=end programlisting

Questo codice è equivalente a ciclare manualmente sui contenuti di C<%canada_addresses>,
ma è molto più compatto.

Che cosa succede se la stessa chiave compare in entrambi gli hash? L'uso di uno slice di hash I<sovrascrive>
sempre le coppie chiave/valore in C<%addresses>. Se desiderate comportamento diverso,
è più appropriato ciclare manualmente.

=head2 L'Hash Vuoto

Un hash vuoto non contiene nè chiavi nè valori. In contesto booleano ha valore
falso. Un hash che contiene almeno una coppia chiave/valora ha invece valore vero in
contesto booleano anche se tutte le chiavi o tutti i valori o entrambi
avessero valore falso in contesto booleano.

=begin programlisting

    use Test::More;

    my %empty;
    ok( ! %empty, 'un hash vuoto dovrebbe avere valore falso' );

    my %false_key = ( 0 => 'valore vero' );
    ok( %false_key, 'un hash contenente falso come chiave
                     dovrebbe avere valore vero' );

    my %false_value = ( 'chiave vera' => 0 );
    ok( %false_value, 'un hash contenente falso come valore
                       dovrebbe avere valore vero' );

    done_testing();

=end programlisting

In contesto scalare, un hash valuta a una stringa che rappresenta la frazione di
posizioni occupate nell'hash--ma potete tranquillamente ignorare questi dettagli
dell'implementazione interna dell'hash.

In contesto lista, un hash valuta a una lista di coppie chiave/valore simile a quella
restituita dall'operatore C<each>.  Tuttavia, non I<potete> iterare su
tale lista allo stesso modo in cui potete iterare sulla lista prodotta da C<each>, poichè
il ciclo non terminerebbe mai:

=begin programlisting

    # ciclo infinito per hash non vuoti
    while (my ($key, $value) = %hash)
    {
        ...
    }

=end programlisting

È I<possibile> ciclare su questa lista di chiavi e valori con un ciclo C<for>, ma la
variabile iteratore conterrà una chiave ad una iterazione e il suo valore in quella successiva,
poichè Perl appiattisce l'hash in un'unica lista di chiavi e valori alternati:

=begin programlisting

    for (%hash)
    {
        ...
    }

=end programlisting

=head2 Idiomi degli Hash

X<hashes; finding uniques>

Poichè ogni chiave può comparire una sola volta in un hash, assegnare la stessa chiave ad un hash più
di una volta memorizza solo il valore più recente. Potete sfruttare questo fatto per trovare gli elementi
distinti di una lista:

=begin programlisting

    my %uniq;
    undef @uniq{ @items };
    my @uniques = keys %uniq;

=end programlisting

L'uso di C<undef> con uno slice di hash setta i valori dell'hash a C<undef>. Questo idioma
rappresenta il modo più efficiente di effettuare operazioni insiemistiche con un hash.

X<hashes; counting items>

Gli hash sono utili anche per contare degli elementi, come gli indirizzi IP in un file di log:

=begin programlisting

    my %ip_addresses;

    while (my $line = <$logfile>)
    {
        my ($ip, $resource) = analyze_line( $line );
        $ip_addresses{$ip}++;
        ...
    }

=end programlisting

Inizialmente ogni valore di un hash è C<undef>. L'operatore di postincremento
(C<++>) lo tratta come se fosse zero. In questo esempio, se il valore della chiave esiste già viene rimpiazzato con
il suo incremento. Se invece non esiste alcun valore per la chiave, Perl crea un
valore (C<undef>) e lo incrementa immediatamente a uno, dato che il valore numerico di
C<undef> è 0.

X<hashes; caching>
X<orcish maneuver>

La seguente strategia costituisce un utile meccanismo di caching per memorizzare il risultato di un'operazione
costosa con un piccolo overhead:

=begin programlisting

    {
        my %user_cache;

        sub fetch_user
        {
            my $id = shift;
            $user_cache{$id} //= create_user($id);
            return $user_cache{$id};
        }
    }

=end programlisting

X<defined-or>
X<C<//>; infix operator>
X<operators; C<//>>
X<operators; defined-or>

Questa I<manovra orcish>N<Or-cache, se vi piacciono i pun.> restituisce il valore dell'hash,
se esso esiste. Altrimenti calcola, mette in cache e restituisce il
valore. L'operatore di assegnamento defined-or (C<//=>) valuta il suo operando di sinistra.
Se tale operando non è definito, l'operatore gli assegna il valore del suo operando di destra.
In altre parole, se non c'è un valore nell'hash per una data
chiave, questa funzione chiama C<create_user()> passandole la chiave e poi aggiorna
l'hash.

Perl 5.10 ha introdotto gli operatori di defined-or e di assegnamento defined-or. Prima
del 5.10, gran parte del codice usava l'operatore di assegnamento boolean-or (C<||=>) per lo stesso
scopo. Purtroppo, alcuni valori validi valutano a falso in contesto booleano, quindi valutare la I<definitezza> dei valori
è quasi sempre più accurato.

Essendo pigra, la manovra orcish testa la definitezza del valore in cache, non
la sua verità.

X<hashes; named parameters>

Se la vostra funzione accetta diversi argomenti, sfruttate la golosità degli hash
(L<parameter_slurping>) per raccogliere delle coppie chiave/valore in un unico hash trattandole come
argomenti passati per nome alla funzione:

=begin programlisting

    sub make_sundae
    {
        my %parameters = @_;
        ...
    }

    make_sundae( aroma  => 'Burst al Limone',
                 glassa => 'biscotti macinati' );

=end programlisting

Questo approccio vi permette anche di settare dei valori di default, in questo modo:

=begin programlisting

    sub make_sundae
    {
        my %parameters             = @_;
        B<$parameters{aroma}   //= 'Vaniglia';>
        B<$parameters{glassa}  //= 'cioccolato';>
        B<$parameters{praline} //= 100;>
        ...
    }

=end programlisting

... oppure includendoli direttamente nell'assegnamento iniziale:

=begin programlisting

    sub make_sundae
    {
        my %parameters =
        (
            B<< aroma    => 'Vaniglia', >>
            B<< glassa   => 'cioccolato', >>
            B<< praline  => 100, >>
            @_,
        );
        ...
    }

=end programlisting

... dato che le successive dichiarazioni della stessa chiave con un diverso valore
sovrascrivono i valori precedenti.

=head2 Bloccare gli Hash

Z<locked_hashes>

X<hashes; locked>

Dato che le chiavi di hash sono delle bareword, offrono poca protezione contro gli errori di scrittura rispetto alla
protezione offerta dalla pragma C<strict> sui nomi di funczione e di variabile. Il
poco conosciuto modulo core C<Hash::Util> fornisce dei meccanismi per migliorare la situazione.

Per revenire l'inserimento accidentale di una chiave di hash indesiderata
(a causa di una svista o di input utente inaffidabile), usate la funzione C<lock_keys()>
per congelare l'hash al suo insieme corrente di chiavi. Ogni tentativo di aggiungere una
nuova chiave all'hash solleverà un'eccezione. Questa è ovviamente una sicurezza debole, adatta solo a
prevenire errori accidentali; chiunque può usare la funzione C<unlock_keys()> per rimuovere
questa protezione.

In modo simile potete bloccare o sbloccare il valore corrente di una data chiave dell'hash
(C<lock_value()> e C<unlock_value()>) e impostare o rilasciare il modo read-only per l'intero hash
con C<lock_hash()> e C<unlock_hash()>.
