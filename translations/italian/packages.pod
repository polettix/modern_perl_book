=head1 Package

Z<packages>
X<packages>
X<namespaces>

Un I<namespace> in Perl associa e incapsula varie entità con nome all'interno di una
categoria con un proprio nome, come potrebbe essere il vostro cognome o il nome di una marca. Al contrario di un nome
nel mondo reale, un namespace non implica alcuna relazione diretta tra le entità. È possibile,
ma non necessario, che vi siano tali relazioni.

In Perl 5 un I<package> è una collezione di codice contenuto in un singolo namespace. La
distinzione è sottile: il package rappresenta il codice sorgente e il namespace
rappresenta l'entità creata quando Perl parsifica tale codice.

X<builtins; C<package>>

La funzione nativa C<package> dichiara un package e un namespace:

=begin programlisting

    package MyCode;

    our @boxes;

    sub add_box { ... }

=end programlisting

X<namespaces; fully qualified>

Tutte le variabili e funzioni globali che dichiarate o a cui fate riferimento dopo la dichiarazione del package
si riferiscono a simboli del namespace C<MyCode>. Potete riferirvi
alla variabile C<@boxes> dal namespace C<main> solo col suo nome I<fully
qualified> C<@MyCode::boxes>. Un nome fully qualified include un
nome completo di package, quindi potete chiamare la funzione C<add_box()> soltanto con
C<MyCode::add_box()>.

X<scope; packages>

Lo scope di un package continua fino alla successiva dichiarazione C<package> oppure fino alle
fine del file, a seconda di ciò che avviene per primo. Perl 5.14 ha potenziato C<package> in modo che
potete fornirgli un blocco che delimita esplicitamente lo scope della
dichiarazione:

=begin programlisting

    package Pinball::Wizard
    {
        our $VERSION = 1969;
    }

=end programlisting

Il package di default è il package C<main>. In assenza di una dichiarazione di package, il
package corrente è C<main>. Questa regola si applica tanto ai programmi a linea di comando quanto ai programmi
standalone e anche ai file F<.pm>.

X<packages; versions>
X<C<$VERSION>>

Oltre al nome, un package ha una versione e tre metodi impliciti:
C<VERSION()>, C<import()> (L<importing>) e C<unimport()>.

C<VERSION()> restituisce il numero di versione del package. Questo numero è in realtà una serie di
numeri contenuti in una variabile globale del package di nome C<$VERSION>. Per convenzione,
le versioni tendono a essere una serie di interi separati dal punto, come C<1.23> o
C<1.1.10>, dove ogni componente è un intero.

X<version numbers>

Perl 5.12 ha introdotto una nuova sintassi intesa asemplificare i numeri di versione, come
documentato in C<perldoc version::Internals>. Questi numeri di versione con forma più restrittiva
devono iniziare con il carattere C<v> e contenere almeno tre componenti intere separate
da punti:

=begin programlisting

    package MyCode v1.2.1;

=end programlisting

In Perl 5.14, la forma opzionale a blocco di una dichiarazione di C<package> è:

=begin programlisting

    package Pinball::Wizard v1969.3.7
    {
        ...
    }

=end programlisting

Nella versione 5.10 e precedenti, il modo più semplice per dichiarare la versione di un package è:

=begin programlisting

    package MyCode;

    our $VERSION = 1.21;

=end programlisting

X<C<UNIVERSAL>>
X<C<VERSION()>>

Ogni package eredita un metodo C<VERSION()> dalla classe base C<UNIVERSAL>.
Potete fare l'override di C<VERSION()>, anche se non ci sono molti motivi per volerlo fare. Tale
metodo restituisce il valore di C<$VERSION>:

=begin programlisting

    my $version = Some::Plugin->VERSION();

=end programlisting

Se gli passate un numero di versione come argomento, il metodo solleverà
un'eccezione a meno che la versione del modulo sia uguale o successiva all'argomento:

=begin programlisting

    # richiesta almeno versione 2.1
    Some::Plugin->VERSION( 2.1 );

    die "Il tuo plugin $version è troppo vecchio"
        unless $version > 2;

=end programlisting

=head2 Package e Namespace

X<namespaces>
X<packages; namespaces>

Ogni dichiarazione C<package> crea, se necessario, un nuovo namespace e impone
al parser di inserire tutti i successivi simboli globali del package (variabili globali e
funzioni) in tale namespace.

X<namespaces; open>

Perl ha dei I<namespace aperti>. Potete aggiungere funzioni e variabili a un namespace
in qualunque punto, sia con una dichiarazione di package:

=begin programlisting

    package Pack
    {
        sub first_sub { ... }
    }

    Pack::first_sub();

    package Pack
    {
        sub second_sub { ... }
    }

    Pack::second_sub();

=end programlisting

... che specificando dei nomi di funzione fully qualified al momento della dichiarazione:


=begin programlisting

    # implicito
    package main;

    sub Pack::third_sub { ... }

=end programlisting

Potete fare aggiunte a un package in ogni punto sia durante la compilazione che a runtime, indipendentemente
dal file corrente, sebbene costruire un package con diverse dichiarazioni
separate può rendere il codice difficile da esplorare.

X<namespaces; multi-level>

I namespace possono avere tanti livelli quanti ne richiede il vostro schema organizzativo,
ma i namespace non sono gerarchici. L'unica relazione tra i package
è semantica, non tecnica. Molti progetti e aziende creano il proprio
namespace di top-level. In questo modo viene ridotta la possibilità di conflitti globali e
viene semplificata l'organizzazione del codice su disco. Per esempio:

=over 4

=item * C<StrangeMonkey> è il nome di un progetto

=item * C<StrangeMonkey::UI> contiene codice top-level dell'interfaccia utente

=item * C<StrangeMonkey::Persistence> contiene codice top-level del codice di gestione dei dati

=item * C<StrangeMonkey::Test> contiene codice top-level per il testing del progetto

=back

... e così via.
