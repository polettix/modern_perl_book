=head1 Strutture Dati Nidificate

Z<nested_data_structures>
X<data structures>
X<nested data structures>

I dati aggregati del Perl--array e hash--vi permettono di memorizzare scalari e
indicizzarli per numero o per chiave. I riferimenti Perl 5 (L<references>) vi permettono
di accedere ai tipi di dati aggregati attraverso speciali variabili scalari. Le strutture dati
nidificate del Perl, come un array di array o un hash di hash, sono
rese possibili dall'uso dei riferimenti.

=head2 Dichiarazione di Strutture Dati Nidificate

Per dichiarare una struttura dati nidificata, usate la sintassi della dichiarazione di riferimenti anonimi:

=begin programlisting

    my @famous_triplets =
    (
        [qw( eenie miney moe   )],
        [qw( huey  dewey louie )],
        [qw( duck  duck  goose )],
    );

    my %meals =
    (
        colazione => { piatto   => 'uova',
                       contorno => 'patatine' },
        pranzo    => { piatto   => 'panini',
                       contorno => 'mela'         },
        cena      => { piatto   => 'bistecca',
                       contorno => 'insalata di avocado' },
    );

=end programlisting

=begin tip Commas are Free

Perl permette, ma non richiede, la virgola finale come modo per facilitare l'aggiunta di nuovi
elementi alla lista.

=end tip

=head2 Accesso a Strutture Dati Nidificate

Usate la sintassi dei riferimenti Perl per accedere agli elementi delle strutture dati nidificate. Il
sigillo denota la quntità di dati da estrarre e la freccia di dereferenziazione
indica che il valore di una porzione della struttura dati è un riferimento:

=begin programlisting

    my $last_nephew = $famous_triplets[1]->[2];
    my $breaky_side = $meals{colazione}->{contorno};

=end programlisting

L'unico modo di nidificare una struttura dati multi-livello è attraverso i riferimenti, quindi la freccia
è superflua. Potete ometterla per chiarezza:

=begin programlisting

    my $last_nephew = $famous_triplets[1][2];
    my $breaky_side = $meals{breakfast}{side};

=end programlisting

=begin tip Save Your Arrows for Functions

La sintassi con la freccia è più chiara solo nel caso in cui vogliate invocare un riferimento a
funzione memorizzato in una struttura dati nidificata.

=end tip

Usate dei blocchi di disambiguazione per accedere ai componenti delle strutture dati nidificate come se fossero
array o hash di first-class:

=begin programlisting

    my $nephew_count   = @{ $famous_triplets[1] };
    my $dinner_courses = keys %{ $meals{dinner} };

=end programlisting

... o per le slice di strutture dati nidificate:

=begin programlisting

    my ($entree, $side) = @{ $meals{colazione} }
                           {qw( piatto contorno )};

=end programlisting

La spaziatura può aiutare, ma non elimina completamente la difficoltà di leggere questo costrutto.
Per essere più chiari, usate delle variabili temporanee:

=begin programlisting

    my $meal_ref        = $meals{colazione};
    my ($entree, $side) = @$meal_ref{qw( piatto contorno )};

=end programlisting

X<aliasing>

... oppure sfruttare l'aliasing implicito a C<$_> del ciclo C<for> per evitare l'uso di un riferimento
intermedio:

=begin programlisting

    my ($entree, $side) = @{ $_ }{qw( piatto contorno )}
                          for $meals{colazione};

=end programlisting

... tenendo sempre a mente l'importanza di essere chiari.

C<perldoc perldsc>, il cookbook sulle strutture dati, fornisce numerosi esempi di uso di varie
strutture dati in Perl.

=head2 Autovivificazione

Z<autovivification>
X<autovivification>

L'espressività del Perl si applica anche alle strutture dati nidificate. Quando tentate di scrivere
dentro un componente di una struttura dati nidificata, Perl creerà il cammino
necessario nella struttura dati fino alla destinazione:

=begin programlisting

    my @aoaoaoa;
    $aoaoaoa[0][0][0][0] = 'profondamente nidificato';

=end programlisting

Dopo la seconda linea di codice, questo array di array di array di array
contiene un riferimento ad array in un riferimento ad array in un riferimento ad array in un 
riferimento ad array. Ogni riferimento ad array contiene un elemento. Analogamente, trattare
un valore non definito come se fosse un riferimento ad hash in una struttura dati nidificata
creerà gli hash intermedi:

=begin programlisting

    my %hohoh;
    $hohoh{Robot}{Santa}{Claus} = 'molto pericoloso';

=end programlisting

X<autovivification>
X<C<autovivification> pragma>
X<pragmas; C<autovivification>>

Questo utile processo è detto I<autovivificazione>. Anche se riduce il codice
di inizializzazione delle strutture dati nidificate, non distingue tra un
vero intento di creare elementi mancanti e gli
errori di battitura. La pragma C<autovivification> di CPAN (L<pragmas>) vi permette di disabilitare
l'autovivificazione in uno scope lessicale per specifici tipi di operazioni.

Potreste vedere una contraddizione nell'idea di sfruttare
l'autovivificazione attivando al contempo controlli come C<strict>. È un problema di bilanciamento.
È più conveniente catturare gli errori che fanno cambiare il comportamento del vostro programma
al costo di disabilitare i controlli su alcuni riferimenti simbolici ben identificati?
È più conveniente permettere alle strutture dati di crescere piuttosto che dover
specificare la loro dimensione e le chiavi permesse?

Le risposte dipendono dal vostro progetto. All'inizio dello sviluppo, concedetevi la libertà
di sperimentare. Quando arrivate al test e alla distribuzione, considerate di incrementare
le restrizioni per evitare effetti collaterali indesiderati. Grazie allo scope lessicale delle
pragma C<strict> e C<autovivification>, potete abilitarle dove
e quando lo ritenete necessario.

Naturalmente I<potreste> verificare le vostre aspettative prima di dereferenziare ogni livello di una
struttura dati complessa, ma il codice risultante sarebbe lungo e tedioso.
La cosa migliore è di evitare strutture dati nidificate troppo profondamente rivedendo il
vostro modello dei dati e migliorarne l'incapsulamento.

=head2 Debugging di Strutture Dati Nidificate

La complessità della sintassi di dereferenziazione di Perl 5 combinata con la potenziale confusione
dovuta a molti livelli di indirezione possono rendere difficile il debugging delle
strutture dati nidificate. Fortunatamente esistono due validi strumenti di visualizzazione.

X<C<Data::Dumper>>

Il modulo core C<Data::Dumper> converte valori di complessità arbitraria in
stringhe di codice Perl 5:

=begin programlisting

    use Data::Dumper;

    print Dumper( $my_complex_structure );

=end programlisting

Può essere utile per vedere che cosa contiene una struttura dati, a che cosa volevate
accedere e a che cosa avete invece acceduto. C<Data::Dumper> può fare il dump di oggetti e anche
di riferimenti a funzione (se settate C<$Data::Dumper::Deparse> al valore vero).

Anche se C<Data::Dumper> è un modulo core e stampa codice Perl 5, il suo output è
verboso. Alcuni sviluppatori preferiscono usare i moduli C<YAML::XS> o C<JSON>
per il debugging. Questi moduli non producono codice Perl 5, ma i loro output possono essere molto
più chiari da leggere e capire.

=head2 Riferimenti Circolari

Z<circular_references>

X<circular references>
X<memory management; circular references>
X<garbage collection>

Il sistema di gestione della memoria di Perl 5 ha un problema con il reference counting (L<reference_counts>)
che diventa visibile al livello del codice utente. Due riferimenti che finiscono indirettamente per puntare l'uno
all'altro formano un I<riferimento circolare> che Perl non può neutralizzare automaticamente.
Considerate un modello biologico, dove ogni entità ha due genitori e zero o più figli:
children:

=begin programlisting

    my $alice  = { madre => '',     padre => ''      };
    my $robert = { madre => '',     padre => ''      };
    my $cianne = { madre => $alice, padre => $robert };

    push @{ $alice->{figli}  }, $cianne;
    push @{ $robert->{figli} }, $cianne;

=end programlisting

Sia C<$alice> che C<$robert> contengono un riferimento ad array che contiene
C<$cianne>. Dato che C<$cianne> è un riferimento a un hash che contiene sia C<$alice> che
C<$robert>, Perl non decrementerà mai il reference count di queste tre persone
a zero. Non riconosce l'esistenza di questi riferimenti circolari e
non può gestire la durata della vita di queste entità.

X<references; weak>
X<weak references>
X<C<Scalar::Util>>

Potete spezzare il circolo manualmente (resettando i figli di
C<$alice> e C<$robert> o i genitori di C<$cianne>), oppure usare i I<riferimenti
deboli>. Un riferimento debole è un riferimento che non incrementa il
reference count del suo referente. I riferimenti deboli sono resi disponibili dal
modulo core C<Scalar::Util>. La funzione C<weaken()> previene l'incremento di un reference count:

=begin programlisting

    use Scalar::Util 'weaken';

    my $alice  = { madre => '',     padre => ''      };
    my $robert = { madre => '',     padre => ''      };
    my $cianne = { madre => $alice, padre => $robert };

    push @{ $alice->{figli}  }, $cianne;
    push @{ $robert->{figli} }, $cianne;

    B<< weaken( $cianne->{madre} ); >>
    B<< weaken( $cianne->{padre} ); >>

=end programlisting

In questo modo C<$cianne> mantiene i suoi riferimenti ad C<$alice> e C<$robert>, ma tali
riferimenti non prevengono il garbage collector del Perl dal distruggere
tali strutture dati. Molte strutture dati non necessitano dei riferimenti
deboli, ma quando sono necessari hanno un valore inestimabile.

=head2 Alternative alle Strutture Dati Nidificate

Anche se il Perl è ben contento di processare strutture dati nidificate a qualunque profondità possiate
immaginare, il costo di comprendere queste strutture dati e le loro relazioni per un lettore
umano è alto--per non dire nulla della complessità della sintassi. Oltre i due o
tre livelli di nidificazione, considerate se modellare i diversi componenti del vostro sistema
con classi e oggetti (L<moose>) non potrebbe rendere più chiaro il vostro codice.
